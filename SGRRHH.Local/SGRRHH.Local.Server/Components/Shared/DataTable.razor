@typeparam TItem
@inject IJSRuntime JSRuntime

<div class="hospital-datatable" id="@TableId" tabindex="0" @onkeydown="HandleKeyDown">
    <div class="datatable-wrapper">
        <table class="hospital-table">
            <thead>
                <tr>
                    @HeaderTemplate
                </tr>
            </thead>
            <tbody>
                @if (IsLoading)
                {
                    <tr>
                        <td colspan="100" class="loading-state">
                            CARGANDO DATOS...
                        </td>
                    </tr>
                }
                else if (Items == null || !Items.Any())
                {
                    <tr>
                        <td colspan="100" class="empty-state">
                            @(EmptyMessage ?? "SIN REGISTROS")
                        </td>
                    </tr>
                }
                else
                {
                    @foreach (var item in Items)
                    {
                        <tr class="@(IsSelected(item) ? "row-selected" : "row-normal")"
                            @onclick="() => SelectItem(item)"
                            @ondblclick="() => OnDoubleClick.InvokeAsync(item)">
                            @RowTemplate?.Invoke(item)
                        </tr>
                    }
                }
            </tbody>
        </table>
    </div>

    @if (ShowPagination && TotalPages > 1)
    {
        <div class="datatable-pagination">
            <div class="pagination-info">
                REGISTROS: @(((CurrentPage - 1) * PageSize) + 1) - @(Math.Min(CurrentPage * PageSize, TotalItems)) DE @TotalItems
            </div>
            <div class="pagination-controls">
                <button class="pagination-btn" @onclick="FirstPage" disabled="@(CurrentPage <= 1)">PRIMERA</button>
                <button class="pagination-btn" @onclick="PreviousPage" disabled="@(CurrentPage <= 1)">ANTERIOR</button>
                <span class="pagination-page">
                    PAGINA 
                    <input type="number" min="1" max="@TotalPages" value="@CurrentPage" 
                           @onchange="OnPageInputChange" class="pagination-input" />
                    DE @TotalPages
                </span>
                <button class="pagination-btn" @onclick="NextPage" disabled="@(CurrentPage >= TotalPages)">SIGUIENTE</button>
                <button class="pagination-btn" @onclick="LastPage" disabled="@(CurrentPage >= TotalPages)">ULTIMA</button>
            </div>
            <div class="pagination-size">
                <span class="pagination-size-label">REGISTROS/PAGINA:</span>
                <select @bind="PageSize" @bind:after="OnPageSizeChanged" class="pagination-select">
                    <option value="10">10</option>
                    <option value="20">20</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                </select>
            </div>
        </div>
    }
    
    @if (ShowKeyboardHints)
    {
        <div class="datatable-keyboard">
            <span class="keyboard-hint"><kbd>↑↓</kbd> NAVEGAR</span>
            <span class="keyboard-hint"><kbd>ENTER</kbd> ABRIR</span>
            <span class="keyboard-hint"><kbd>HOME</kbd> INICIO</span>
            <span class="keyboard-hint"><kbd>END</kbd> FIN</span>
        </div>
    }
</div>

@code {
    [Parameter] public IEnumerable<TItem>? Items { get; set; }
    [Parameter] public RenderFragment? HeaderTemplate { get; set; }
    [Parameter] public RenderFragment<TItem>? RowTemplate { get; set; }
    [Parameter] public string? EmptyMessage { get; set; }
    [Parameter] public bool IsLoading { get; set; }
    
    [Parameter] public TItem? SelectedItem { get; set; }
    [Parameter] public EventCallback<TItem?> SelectedItemChanged { get; set; }
    [Parameter] public EventCallback<TItem> OnDoubleClick { get; set; }
    [Parameter] public EventCallback<TItem> OnEnterPressed { get; set; }
    
    [Parameter] public bool ShowPagination { get; set; }
    [Parameter] public int CurrentPage { get; set; } = 1;
    [Parameter] public EventCallback<int> CurrentPageChanged { get; set; }
    [Parameter] public int PageSize { get; set; } = 20;
    [Parameter] public EventCallback<int> PageSizeChanged { get; set; }
    [Parameter] public int TotalItems { get; set; }
    [Parameter] public EventCallback<int> OnPageChanged { get; set; }
    
    [Parameter] public bool ShowKeyboardHints { get; set; } = true;
    [Parameter] public string? TableId { get; set; }
    
    private string _tableId = "";
    
    protected override void OnInitialized()
    {
        _tableId = TableId ?? $"datatable-{Guid.NewGuid():N}";
    }

    private int TotalPages => TotalItems > 0 ? (int)Math.Ceiling((double)TotalItems / PageSize) : 1;

    private bool IsSelected(TItem item)
    {
        if (SelectedItem == null || item == null) return false;
        return EqualityComparer<TItem>.Default.Equals(item, SelectedItem);
    }

    private async Task SelectItem(TItem item)
    {
        SelectedItem = item;
        await SelectedItemChanged.InvokeAsync(item);
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        switch (e.Key)
        {
            case "ArrowDown":
                await SelectNextAsync();
                break;
            case "ArrowUp":
                await SelectPreviousAsync();
                break;
            case "Enter":
                if (SelectedItem != null)
                {
                    await OnEnterPressed.InvokeAsync(SelectedItem);
                    await OnDoubleClick.InvokeAsync(SelectedItem);
                }
                break;
            case "Home":
                await SelectFirstAsync();
                break;
            case "End":
                await SelectLastAsync();
                break;
        }
    }

    private async Task FirstPage()
    {
        if (CurrentPage != 1)
        {
            CurrentPage = 1;
            await CurrentPageChanged.InvokeAsync(CurrentPage);
            await OnPageChanged.InvokeAsync(CurrentPage);
        }
    }

    private async Task PreviousPage()
    {
        if (CurrentPage > 1)
        {
            CurrentPage--;
            await CurrentPageChanged.InvokeAsync(CurrentPage);
            await OnPageChanged.InvokeAsync(CurrentPage);
        }
    }

    private async Task NextPage()
    {
        if (CurrentPage < TotalPages)
        {
            CurrentPage++;
            await CurrentPageChanged.InvokeAsync(CurrentPage);
            await OnPageChanged.InvokeAsync(CurrentPage);
        }
    }

    private async Task LastPage()
    {
        if (CurrentPage != TotalPages)
        {
            CurrentPage = TotalPages;
            await CurrentPageChanged.InvokeAsync(CurrentPage);
            await OnPageChanged.InvokeAsync(CurrentPage);
        }
    }

    private async Task OnPageInputChange(ChangeEventArgs e)
    {
        if (int.TryParse(e.Value?.ToString(), out int newPage))
        {
            newPage = Math.Max(1, Math.Min(newPage, TotalPages));
            if (CurrentPage != newPage)
            {
                CurrentPage = newPage;
                await CurrentPageChanged.InvokeAsync(CurrentPage);
                await OnPageChanged.InvokeAsync(CurrentPage);
            }
        }
    }

    private async Task OnPageSizeChanged()
    {
        CurrentPage = 1;
        await PageSizeChanged.InvokeAsync(PageSize);
        await CurrentPageChanged.InvokeAsync(CurrentPage);
        await OnPageChanged.InvokeAsync(CurrentPage);
    }

    /// <summary>
    /// Selecciona el siguiente item en la lista
    /// </summary>
    public async Task SelectNextAsync()
    {
        if (Items == null || !Items.Any()) return;
        
        var itemList = Items.ToList();
        var currentIndex = SelectedItem != null ? itemList.IndexOf(SelectedItem) : -1;
        
        if (currentIndex < itemList.Count - 1)
        {
            await SelectItem(itemList[currentIndex + 1]);
            await ScrollToSelected();
        }
    }

    /// <summary>
    /// Selecciona el item anterior en la lista
    /// </summary>
    public async Task SelectPreviousAsync()
    {
        if (Items == null || !Items.Any()) return;
        
        var itemList = Items.ToList();
        var currentIndex = SelectedItem != null ? itemList.IndexOf(SelectedItem) : -1;
        
        if (currentIndex > 0)
        {
            await SelectItem(itemList[currentIndex - 1]);
            await ScrollToSelected();
        }
    }

    /// <summary>
    /// Selecciona el primer item
    /// </summary>
    public async Task SelectFirstAsync()
    {
        if (Items != null && Items.Any())
        {
            await SelectItem(Items.First());
            await ScrollToSelected();
        }
    }

    /// <summary>
    /// Selecciona el último item
    /// </summary>
    public async Task SelectLastAsync()
    {
        if (Items != null && Items.Any())
        {
            await SelectItem(Items.Last());
            await ScrollToSelected();
        }
    }

    private async Task ScrollToSelected()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("scrollToSelectedRow", _tableId);
        }
        catch { }
    }

    /// <summary>
    /// Enfoca la tabla para navegación con teclado
    /// </summary>
    public async Task FocusAsync()
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("focusTable", _tableId);
        }
        catch { }
    }

    // Métodos invocables desde JS
    [JSInvokable]
    public async Task SelectNextRow() => await SelectNextAsync();
    
    [JSInvokable]
    public async Task SelectPreviousRow() => await SelectPreviousAsync();
    
    [JSInvokable]
    public async Task SelectFirstRow() => await SelectFirstAsync();
    
    [JSInvokable]
    public async Task SelectLastRow() => await SelectLastAsync();
    
    [JSInvokable]
    public async Task OpenSelectedRow()
    {
        if (SelectedItem != null)
        {
            await OnDoubleClick.InvokeAsync(SelectedItem);
        }
    }
}


